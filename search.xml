<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Timer定时器浅析]]></title>
    <url>%2F2018%2F01%2F17%2FTimer%E5%AE%9A%E6%97%B6%E5%99%A8%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Timer类图 Timer内部持有一个TaskQueue和一个TimerThread TimerThread默认是非守护线程，构造方法可指定是否是守护线程，是为true TaskQueue内部是一个TimerTask数组（小根堆），初始化大小为128，TimerTask是抽象类，自定义任务需实现TimerTask TaskQueue中的TimerTask从index为1开始存储，每次添加会加入数组的尾部（追加操作，若需要扩容则扩容，2倍扩容），之后会根据新加入的任务的调度时间进行调整，每次执行新任务则是取index为1(小根堆堆顶元素)的TimerTask进行执行 每个Timer调度的任务队列TaskQueue由同一个TimerTread实例执行 Timer不保证按照预计的时间执行，因为当TaskQueue内部有多个task时，其根据预计执行时间顺序排序执行，由于是一条线程，若前者任务执行过长，则后序任务延后 Task的几种状态 状态 释义 VIRGIN = 0; 未被调度的任务，即未纳入Timer调度管理下 SCHEDULED = 1; 纳入Timer调度管理下，即放入TaskQueue EXECUTED = 2; 任务被调度过 CANCELLED = 3; 任务被取消 任务的取消 Task的cancle方法，返回取消任务之前该任务是否是Timer预计执行的任务（计划执行，还未执行，true则是未执行，false可能是已执行，也可能是未纳入Timer调度），被取消的任务将在TimerThread线程的主循环中从TaskQueue中移除 1234567public boolean cancel() &#123; synchronized(lock) &#123; boolean result = (state == SCHEDULED); state = CANCELLED; return result; &#125;&#125; Timer的cancle方法，清空TaskQueue，并指明不会再有新任务加入进来 1234567public void cancel() &#123; synchronized(queue) &#123; thread.newTasksMayBeScheduled = false; queue.clear(); queue.notify(); // In case queue was already empty. &#125;&#125; TimerThread的主循环1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public void run() &#123; try &#123; mainLoop(); &#125; finally &#123; // Someone killed this Thread, behave as if Timer cancelled synchronized(queue) &#123; newTasksMayBeScheduled = false; queue.clear(); // Eliminate obsolete references &#125; &#125;&#125;private void mainLoop() &#123; while (true) &#123; try &#123; TimerTask task; boolean taskFired; synchronized(queue) &#123; // Wait for queue to become non-empty while (queue.isEmpty() &amp;&amp; newTasksMayBeScheduled) queue.wait(); if (queue.isEmpty()) break; // Queue is empty and will forever remain; die // Queue nonempty; look at first evt and do the right thing long currentTime, executionTime; task = queue.getMin(); synchronized(task.lock) &#123; if (task.state == TimerTask.CANCELLED) &#123; queue.removeMin(); continue; // No action required, poll queue again &#125; currentTime = System.currentTimeMillis(); executionTime = task.nextExecutionTime; if (taskFired = (executionTime&lt;=currentTime)) &#123; if (task.period == 0) &#123; // Non-repeating, remove queue.removeMin(); task.state = TimerTask.EXECUTED; &#125; else &#123; // Repeating task, reschedule queue.rescheduleMin( task.period&lt;0 ? currentTime - task.period : executionTime + task.period); &#125; &#125; &#125; if (!taskFired) // Task hasn't yet fired; wait queue.wait(executionTime - currentTime); &#125; if (taskFired) // Task fired; run it, holding no locks task.run(); &#125; catch(InterruptedException e) &#123; &#125; &#125;&#125; 主循环中判断taskQueue是否为空，空且timer未取消，则进行wait，等待task加入后唤醒 当taskQueue非空，则取出最近要执行的task，如该task状态已取消，则将其从队列中移除，否则进行判断：如预计执行时间已过，则立即执行，否则，计算还需等待多长时间，进行wait(time)，循环此操作 针对重复执行的任务，两套api方法区别在于带fixedrate的下次执行时间是预计时间+delay，不带的下次执行时间则是当次实际执行时间+delay 关于添加任务和移除任务TaskQueue的调整添加任务1234567891011121314151617void add(TimerTask task) &#123; // Grow backing store if necessary if (size + 1 == queue.length) queue = Arrays.copyOf(queue, 2*queue.length); queue[++size] = task; fixUp(size);&#125;private void fixUp(int k) &#123; while (k &gt; 1) &#123; int j = k &gt;&gt; 1; if (queue[j].nextExecutionTime &lt;= queue[k].nextExecutionTime) break; TimerTask tmp = queue[j]; queue[j] = queue[k]; queue[k] = tmp; k = j; &#125;&#125; 添加任务首先追加在数组尾部，之后通过fixUp方法调整堆上浮插入节点到合适位置 调整堆堆数元素个数做了个判断，非大于1即为1，说明此时即小根堆顶元素，无需调整 否则进行调整，根据堆存储结构特性，子元素×2即为父元素index，不断进行与父节点进行比较，直至找到合适的位置 任务移除1234567891011121314151617void removeMin() &#123; queue[1] = queue[size]; queue[size--] = null; // Drop extra reference to prevent memory leak fixDown(1);&#125;private void fixDown(int k) &#123; int j; while ((j = k &lt;&lt; 1) &lt;= size &amp;&amp; j &gt; 0) &#123; if (j &lt; size &amp;&amp; queue[j].nextExecutionTime &gt; queue[j+1].nextExecutionTime) j++; // j indexes smallest kid if (queue[k].nextExecutionTime &lt;= queue[j].nextExecutionTime) break; TimerTask tmp = queue[j]; queue[j] = queue[k]; queue[k] = tmp; k = j; &#125;&#125; 任务移除操作，则是直接用尾节点替换根节点，之后通过fixDown下沉根节点到合适位置 每次与两个子节点中较小节点进行比较，进行交换操作，直到合适位置]]></content>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java集合分析]]></title>
    <url>%2F2018%2F01%2F15%2FJava%E9%9B%86%E5%90%88%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Collection常用集合类图 迭代接口Iterable 实现该接口拥有迭代集合元素的能力 实现该接口类一般内部定义一个迭代器Iterator接口的实现，如ArrayList内部定义的迭代器Itr 集合的for in语法糖使用的就是Iterator的迭代循环 对于迭代中remove，不使用迭代器的remove方法，会抛出ConcurrentModificationException异常，如ArrayList的每次add、remove操作，都会对modCount++，而每次迭代会检验expectedModCount是否等于modCount，如果不等则抛出异常，虽然作为局部变量的list不会出现并发修改的问题，但是JVM需要对所有情况进行考虑，如果是非局部变量是可能出现该问题的。当然，使用迭代器的remove方法在并发情况下也是会抛出该异常的。 顶层接口Collection 实现Iterable接口，拥有可以迭代的能力 内部定义了作为集合应有的一些行为，如add、remove等 子接口List、Set、Queue对Collection的行为进行扩展 AbstractCollection为Collection的行为默认实现，其子类AbstractList、AbstractSet、AbstractQueue分别是对Collection子接口List、Set、Queue的部分行为的默认实现 List接口的实现 线性表，其底层实现基于两种数据结构：数组和链表基于数组 随机访问速度快，指定下标的记录访问时间复杂度O(1) 数据的遍历，从前往后，时间复杂度O(n) 数据的删除，需要进行数据复制 数据的插入，需要进行数据复制，可能需要扩容 数据的添加，可能需要扩容 元素节点数量最大为Integer.MAX_VALUE = 0x7fffffff; 基于链表 随机访问指定下标的记录时间复杂度O(n) 数据的遍历，从前往后，时间复杂度O(n) 数据的插入、新增、删除效率较高，需要遍历到指定位置后对节点的指针进行修改 元素节点的数量无限制 ArrayList的扩容机制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private static final int DEFAULT_CAPACITY = 10;private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125;public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 默认构造函数内部数组为DEFAULTCAPACITY_EMPTY_ELEMENTDATA，是一个长度为0的数组，其和指定capacity(容量)为0的构造函数区别在于，指定capacity为0的构造函数初始化的对象，内部数组是EMPTY_ELEMENTDATA，这也是一个长度为0的数组，至于为什么不用同一个数组，是为了区分不同的数组扩容策略 添加元素首先要通过ensureCapacityInternal方法来确保最小需要的容量是否满足，此处对是否是默认构造函数初始化的ArrayList做了额外处理，minCapacity取max(DEFAULT_CAPACITY,minCapacity) 再通过ensureExplicitCapacity方法明确需要的最小容量，如果minCapacity大于之前内部数组的length，则执行扩容 默认的扩容机制是扩容为max(1.5*oldCapacity, minCapacity) 首先判断minCapacity是否为负，为负说明所需容量大于int范围，抛出异常，若该扩容值大于定义的MAX_ARRAY_SIZE，则取Integer.MAX_VALUE Vector的扩容机制123456789101112131415161718192021222324252627282930313233343536public Vector(int initialCapacity) &#123; this(initialCapacity, 0);&#125;public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); this.elementData = new Object[initialCapacity]; this.capacityIncrement = capacityIncrement;&#125;public Vector() &#123; this(10);&#125;public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true;&#125;private void ensureCapacityHelper(int minCapacity) &#123; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + ((capacityIncrement &gt; 0) ? capacityIncrement : oldCapacity); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); elementData = Arrays.copyOf(elementData, newCapacity);&#125; 可以看到Vector默认构造函数初始化数组大小是10 可以指定增长幅度capacityIncrement，增长幅度默认为0 当增幅为0时，其默认扩容策略取max(minCapacity, 2*oldCapacity) 当增幅大于0时，其默认扩容策略取max(minCapacity, oldCapacity + capacityIncrement) 其余和ArrayList保持一致 LinkedList提升检索速度的机制 LinkedList不仅实现了List接口，同时实现了Deque接口，该接口表示拥有双端队列的能力 使用头结点和尾节点来标识一个LinkedList，且是一个双向链表 检索时，通过检索下标是否过半，决定从头结点还是尾节点开始遍历 通过双倍指针的开销将检索的时间复杂度缩小为O(n/2) 1234567891011121314Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; ArrayList、SynchronizedList、Vector的区别 ArrayList是非线程安全的，其余二者是线程安全的 SynchronizedList是Collections的内部类，其内部持有一个List的实现，并且提供List的方法实现，使用同步代码块包裹持有的List实例的操作 Vector则是使用同步方法 SynchronizedList和Vector的扩容机制不一样 Set接口的实现 相对于List，其特性是无重复数据HashSet 内部持有一个HashMap 以HashMap的key作为表记录的存储，value为HashSet类的常量PRESENT，就是个Object对象 对使用集合来初始化的构造方法，容量设置为(c.size()/.75f) + 1，保证使用的容量在负载因子限定的容量范围内，避免addAll时，不必要的扩容操作 由于内部是hashMap，所以内部元素是无序的 1234567891011121314151617181920212223# 内部持有HashMap对象private transient HashMap&lt;E,Object&gt; map;# value值private static final Object PRESENT = new Object();public HashSet() &#123; map = new HashMap&lt;&gt;();&#125;public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c);&#125;public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor);&#125;public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity);&#125;public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125;public boolean remove(Object o) &#123; return map.remove(o)==PRESENT;&#125; LinkedHashSet HashSet的子类 内部持有一个LinkedHashMap 其构造方法基于父类HashSet的构造方法，初始化一个LinkedHashSet 能够保证有序的遍历，该特性基于LinkedHashMap的实现 HashSet定义了一个包访问权限的三参数构造方法供子类LinkedHashSet构造方法调用 12345678# HashSet的构造方法HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125;# LinkedHashSetpublic LinkedHashSet() &#123; super(16, .75f, true);&#125; 针对LinkedHashSet如何保证顺序遍历，请参见后续Map相关内容Queue接口的实现 队列的特性是先进先出，对比栈的特性是先进后出，Stack是Vector的子类具体看下比较常用的子接口BlockingQueue阻塞队列 阻塞队列能够在队列空时阻塞取操作，队列满时阻塞存操作 add方法当没有可用的空间时抛出异常IllegalStateException offer方法没有可用的空间返回false，成功添加返回true put方法没有可用的空间阻塞等待被唤醒 offer带参方法如果没有可用的空间，等待指定时间后再次尝试，成功返回true，失败false take方法获取元素如果队列为空则阻塞等待队列中新进元素唤醒 poll方法获取元素，如果队列为空则等待指定时间再次获取，成功返回true，失败false remainingCapacity方法获取当前可用空间大小 ArrayBlockingQueue的实现 队列元素存储结构为数组，可定义队列元素大小 通过内部持有一个ReentrantLock实例lock来实现阻塞队列的特性 基于lock内部定义两个Condition：notEmpty和notFull来实现队列空和满的阻塞与唤醒 put和take共用一个锁对象，二者之间会阻塞 基于队列先进先出的特性，内部数组可以循环操作，定义了takeIndex和putIndex用于标记获取元素和添加元素的下标，同时执行获取/添加操作会修改当前队列元素大小count，该count是普通变量，因此考虑put和tack操作互斥1234567891011#到达数组尾部，循环到数组头private void enqueue(E x) &#123; // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; items[putIndex] = x; if (++putIndex == items.length) putIndex = 0; count++; notEmpty.signal();&#125; LinkedBlockingQueue 队列元素存储基于链表存储，且是单向链表，基于头尾节点标识一个链表 虽然链表无长度限制，但是LinkedBlockingQueue的队列大小需要设置容量，默认是Integer.MAX_VALUR 内部持有锁ReentrantLock的实例takeLock以及条件notEmpty用于阻塞唤醒获取操作 内部持有锁ReentrantLock的实例putLock以及条件notFull用于阻塞唤醒添加操作 队列当前元素大小由AtomicInteger实例count记录，因此take和put操作可并发执行，所以采用两把锁 相比较ArrayBlockingQueue，take和put不相互阻塞，效率更高，但是空间占用高于前者 SynchronousQueue 内部元素只有一个 每一个插入操作必须等待其他线程的移除操作，反之亦然 内部通过cas实现 Map常用集合类图 单词表 英文 中文 capacity 容量 internal 内部 ensure 确保 explicit 明确]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kafka概念]]></title>
    <url>%2F2018%2F01%2F12%2Fkafka%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[Kafka是一个分布式流平台流平台应该包括以下三个关键能力 能够发布和订阅流记录，在这个层面它类似一个消息队列或者企业级消息系统 能够以容错的方式存储流记录 流记录能够被处理当其在产生时 Kafka擅长于如下两大类应用 构建一个实时的流数据管道能够可靠的在系统或应用间获取数据 构建一个实时的流应用用于传输或者响应流数据 相关概念 Kafka以集群的方式运行在一个或多个服务器上 Kafka集群在分类中存储流记录，该分类叫做主题 每条记录由一个key（键）、一个value（值）、一个timestamp（时间戳）组成 Kafka的四个核心API Producer API 其允许应用程序发布流记录到一个或多个kafka的topic Consumer API 其允许应用程序去订阅一个或多个topic并且处理产生给当前应用程序的流记录 Streams API 其允许应用程序充当流处理器，消费来自一个或多个topic的输入流并且产生输出流到一个或多个topic，有效的将输入流转化为输出流 Connector API 其允许构建和运行可重用的生产者或者消费者用于将Kafka的topic连接到在现有的应用或者数据系统中，比如一个连接到关系型数据库的连接器可能会捕获对表的每个更改 Kafka的通讯机制 TCP Kafka使用简单、高性能、语言无关的TCP协议在客户端与服务端之间通信。TCP协议是有版本标识的并且保持向后兼容旧的版本，Kafka官网为Kafka提供了Java的客户端，但是客户端可以是很多种语言。 主题和日志单词表 英文 翻译 in this respact 在这个方面 fault-tolerant way 容错的方式 fault 故障 tolerant 宽容 two broad classes of application 两大类应用 broad 广泛的 reliably 可靠 dive in and explore 深入探索 dive 潜水 bottom up 自下而上 priciple 原理 concept 概念 consist 组成 consist of 由什么组成 act as 充当 reusable 可重复使用的、可重用的 recyclable 可循环使用的、可重用的 reclaimable 可回收的 existing 已存在的、现有的 capture 捕获 performance 性能 capability 能力 maintain 保持、维护 backwards compatibility 向后兼容性 compatibility 兼容性、和好 for each topic 对于每个主题 each 每个 partition 分区 anotomy 剖析、解剖学]]></content>
      <tags>
        <tag>kafka</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小小服务器配置篇]]></title>
    <url>%2F2018%2F01%2F11%2F%E5%B0%8F%E5%B0%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E7%AF%87%2F</url>
    <content type="text"><![CDATA[su 和 su - 的区别 su切换用户时，不会加载/etc/profile文件，但是会加载当前用户目录的~/.bashrc su - 切换用户时，会加载/etc/profile文件，/etc/profile中会加载/etc/bash.bashrc ~/.bashrc文件备份 vim ~/.bashrc 命令行:1定位到文件头，命令行:$定位到文件尾，命令行:%d删除全部内容 在文件末尾追加如下内容 12345678source /etc/profilealias dsudo=&apos;echo &quot;password&quot;|sudo -S&apos;alias pg=&apos;ps -ef|grep&apos;alias sk=&apos;sudo kill -9&apos;alias spk=&apos;sudo pkill -9&apos;alias dsk=&apos;dsudo kill -9&apos;alias dspk=&apos;dsudo pkill -9&apos;alias pk=&apos;pkill -9&apos; 开机启动脚本 脚本中使用sudo： echo “password”|sudo -S command vim /app/data/shell/init.sh#####版本一1234567891011121314#!/bin/sh# 该脚本用于开机启动相关应用# 启动nginx，如果存在先killecho &quot;password&quot;|sudo -S pkill -9 nginxecho &quot;password&quot;|sudo -S env PATH=$PATH nginx# 启动frp-client，如果存在先killpkill -9 frpcd /app/soft/frp-9nohup ./frpc -c f9.ini &gt;/dev/null 2&gt;/dev/null &amp;cd /app/soft/frp-14nohup ./frpc -c f14.ini &gt;/dev/null 2&gt;/dev/null &amp; 版本二 使用alias命令 引入~/.bashrc，通过–login或者source ~/.bashrc 开启别名扩展，交互式shell默认开启，脚本非交互式shell未开启，手动开启shopt -s expand_aliases 针对~/.bashrc进行修改，将下面内容注释12345# If not running interactively, don&apos;t do anythingcase $- in *i*) ;; *) return;;esac If not running interactively, don’t do anything该句说明，若非交互式shell，则什么也不做，return 1234567891011121314151617#!/bin/bash --login# --login 加载~/.bashrc# 或者使用 source ~/.bashrc# source ~/.bashrc# 该脚本用于开机启动相关应用# 脚本下启用aliasshopt -s expand_aliases# 启动nginx，如果存在先killdspk nginxdsudo nginx# 启动frp-client，如果存在先killpk frpcd /app/soft/frp-9nohup ./frpc -c f9.ini &gt;/dev/null 2&gt;/dev/null &amp;cd /app/soft/frp-14nohup ./frpc -c f14.ini &gt;/dev/null 2&gt;/dev/null &amp; 执行权限 chmod 774 /app/data/shell/init.sh开机启动该脚本 编辑/etc/rc.local文件 在最后exit0前加上/app/data/shell/init.sh 用于开机执行该脚本 rc.local文件的文件头是#!/bin/sh 由于rc.local是由root用户权限调用，且此时还未加载/etc/.profile中的环境变量，所以修改以上脚本如下123456789101112131415#!/bin/sh# 开机启动是root用户调用# 该脚本用于开机启动相关应用# 启动nginx，如果存在先killpkill -9 nginx# 指定全路径/app/soft/nginx/sbin/nginx# 启动frp-client，如果存在先killpkill -9 frpcd /app/soft/frp-9nohup ./frpc -c f9.ini &gt;/dev/null 2&gt;/dev/null &amp;cd /app/soft/frp-14nohup ./frpc -c f14.ini &gt;/dev/null 2&gt;/dev/null &amp; 以上操作完毕，开机自启成功]]></content>
      <tags>
        <tag>瞎折腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小小服务器入手折腾篇]]></title>
    <url>%2F2018%2F01%2F10%2F%E5%B0%8F%E5%B0%8F%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8A%98%E8%85%BE%E7%AF%87%2F</url>
    <content type="text"><![CDATA[观望了许久Orange pi zero，今天终于入手到货了，首先放图 上图包括一个主板、一个扩展板、一个散热片、一个主机盒首先第一步烧录系统，当然在快递的路上就烧录好了系统，armbina的ubuntu-server版本armbian地址：https://www.armbian.com/预测已知问题 考虑到不外接显示器显示的情况下，只能通过wifi连接到路由器，然后ssh ip进行连接终端 连接wifi需要配置/etc/network/interfaces文件 内存卡烧录镜像后，格式变为ext格式，win10下无法正常访问 所以首先第一步要先能够win10下访问ext磁盘尝试过ext2fat这个工具，但是在win10下无法开启，失败告终。。 想到ext是linux磁盘格式，linux下能够访问，还好我本机有vm，虚拟机是ubuntu-server 编辑虚拟机配置，添加硬盘，虚拟磁盘类型任选，选择分区电脑主硬盘一般是0结尾，我只拆了内存卡是1结尾，一直下一步直到完成 启动虚拟机，sudo fdisk -l,就能查看到挂载的硬盘以及分区，我的是/dev/sdb1 在/mnt下创建armbian目录用于挂载/dev/sdb1 挂载操作：sudo mount /dev/sdb1 /mnt/armbian 之后cd /mnt/armbian即可进入编辑内存卡中内容 编辑/etc/network/interfaces坚持备份的习惯，我之后的遭遇很庆幸这里备份了该文件。。123cd /etc/networksudo cp interfaces interfaces.baksudo vim interfaces 下面分析下interfaces已有的内容12345678910111213141516171819202122232425262728293031source /etc/network/interfaces.d/*# Wired adapter #1allow-hotplug eth0no-auto-down eth0iface eth0 inet dhcp#gateway 192.168.0.1#dns-nameservers 8.8.8.8 8.8.4.4# hwaddress ether # if you want to set MAC manually# Wireless adapter #1# Armbian ships with network-manager installed by default. To save you time# and hassles consider using &apos;sudo nmtui&apos; instead of configuring Wi-Fi settings# manually. The below lines are only meant as an example how configuration could# be done in an anachronistic way:# #allow-hotplug wlan0#iface wlan0 inet dhcp#address 192.168.0.100#netmask 255.255.255.0#gateway 192.168.0.1#dns-nameservers 8.8.8.8 8.8.4.4# wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf# Disable power saving on compatible chipsets (prevents SSH/connection dropouts over WiFi)#wireless-mode Managed#wireless-power off# Local loopbackauto loiface lo inet loopback 主要观察18、19行，可以看到armbian的配置文件默认提供了一个配置模板，只是在这里注释了，对其做如下操作 取消18、19行注释 加上auto wlan0，表示自动连接wlan0,这个wlan0就是wifi连接 配置wifi的用户名 wpa-ssid nsn 配置wifi的密码 wpa-psk xxxxxx 局部配置如下12345allow-hotplug wlan0auto wlan0iface wlan0 inet dhcpwpa-ssid nsnwpa-psk xxxxxx 一般正确的编辑/etc/network/interfaces文件后，是能够连上无线的，但是此处有个大坑 插上内存卡上电，由于时刻关注路由管理界面，发现确实是有新设备连接到路由的，但是过了一会就断开了，这是因为第一次上电，会初始化系统以及对内存卡重新分区等操作，初始化系统后，/etc/network/interfaces文件里面的配置就为空了，此时做如下操作 断电，取出内存卡使用虚拟机挂载 从interfaces.bak文件恢复interfaces: cp interfaces.bak interfaces 依据之前的配置再重新配置一遍 至于第一次上电初始化系统是否需要连接网络，这个未实验，总之我的是连接网络的情况下初始化的。。配置成功后上卡，成功连接上wifi，首次登陆需要修改密码，放上xshell连接图 armbian系统占用内存还是很小的，初始化结束内存仅占用7%，当前的10%是我装了一些软件开启后的结果 以上完成后就可以随意折腾了，下面的我个人自用操作。。成功连接后，开始迁移之前的小服务器数据。。之前的服务器上图。。 上图的手机是之前换掉的手机，使用LinuxDeploy软件安装的ubuntu-server，当然前提需要获取root权限，如想要在手机上安装linux，下附链接 手机上安装linux操作:https://blog.mlapp.cn/134.html LinuxDeploy应该是基于chroot来实现linux的运行，但是貌似因为安卓的内核和实际linux内核还是有一些差距的，导致一些软件不能很好地运行 比如arm版本的jdk，从官网下载的arm版本的jdk无法在LinuxDeploy的ubuntu上执行，貌似是因为相关的库不太一样，导致只能使用OPENJDK，但是arm的这个OPENJDK实现的很粗糙，性能很弱，曾经在上面部署jenkins，启动了几个小时。。 通过java -version，可以看到对应的VM信息是Zero VM1234nsn@localhost:~$ java -versionopenjdk version &quot;1.8.0_03-Ubuntu&quot;OpenJDK Runtime Environment (build 1.8.0_03-Ubuntu-8u77-b03-3ubuntu3-b03)OpenJDK Zero VM (build 25.03-b03, interpreted mode) 换成新到的小板子，果然官网下载的arm-jdk是能够使用的 提供下载地址，oracle貌似现在有两个地址，一个是需要登录验证的，一个不需要登录，当然从主页进去的就是新版的需要登录验证的，这个老地址也是找了好久找到了，贴在这里备忘 jdk下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 下载解压后进入bin下执行java -version，可以看到对应的VM信息是Hotspot VM 1234nsn@orangepizero:/app/soft/jdk1.8/bin$ ./java -versionjava version &quot;1.8.0_151&quot;Java(TM) SE Runtime Environment (build 1.8.0_151-b12)Java HotSpot(TM) Client VM (build 25.151-b12, mixed mode) 配置JAVA环境变量1234567nsn@orangepizero:/$ sudo vim /etc/profile# 在文件末尾追加如下内容export JAVA_HOME=/app/soft/jdk1.8export CLASSPATH=$JAVA_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$PATH# 生效配置nsn@orangepizero:/$ source /etc/profile 使用scp命令复制相关数据为了避免每次都输入密码验证，首先添加ssh信任：ubuntu常用操作安装花生壳：花生壳相关操作 花生壳用于内网穿透，关于花生壳的使用此处不说，如有需要请自行百度，之前使用手机服务器时，每次用花生壳的sn码登录都说是初次登陆请初始化密码，这次使用小板子并没有发现此种情况 类似的工具还有frp等，可以使用开发者提供的frp-server来实现内网穿透，免费且不限制流量，但是有时候可能没有花生壳稳定，具体内容参见：http://diannaobos.com/frp/ 安装nginx 下载安装包 wget http://nginx.org/download/nginx-1.12.2.tar.gz 解压安装包 tar xzvf nginx-1.12.2.tar.gz 进入解压目录 ./configure –prefix=/app/soft/nginx 安装 sudo make install 配置环境变量将/app/soft/nginx/sbin加入PATH12345678910111213nginx path prefix: &quot;/app/soft/nginx&quot;nginx binary file: &quot;/app/soft/nginx/sbin/nginx&quot;nginx modules path: &quot;/app/soft/nginx/modules&quot;nginx configuration prefix: &quot;/app/soft/nginx/conf&quot;nginx configuration file: &quot;/app/soft/nginx/conf/nginx.conf&quot;nginx pid file: &quot;/app/soft/nginx/logs/nginx.pid&quot;nginx error log file: &quot;/app/soft/nginx/logs/error.log&quot;nginx http access log file: &quot;/app/soft/nginx/logs/access.log&quot;nginx http client request body temporary files: &quot;client_body_temp&quot;nginx http proxy temporary files: &quot;proxy_temp&quot;nginx http fastcgi temporary files: &quot;fastcgi_temp&quot;nginx http uwsgi temporary files: &quot;uwsgi_temp&quot;nginx http scgi temporary files: &quot;scgi_temp&quot; 执行configure的时候可能会报错提示缺少pcre，ubuntu下通过安装以下库解决 1sudo apt-get install libpcre3 libpcre3-dev scp复制博客配置 conf目录下nginx.conf文件http标签中include指定文件：include /app/soft/nginx/conf/myconf/*.conf scp ./blog.conf root@192.168.1.104:/app/soft/nginx/conf/myconf 注意nginx相关的操作权限是root用户 12345678server &#123; listen 8080; server_name localhost; location / &#123; root /app/data/blog; index index.html; &#125;&#125; 启动nginx：sudo nginx，无法找到nginx命令 原因是sudo命令执行后，可执行命令的路径为/etc/sudoers文件中secure_path配置的路径，针对此问题，将/app/soft/nginx/sbin加入到该路径中即可 或者可以使用sudo env PATH=$PATH nginx，指定PATH环境 启动nginx：sudo nginx，启动成功后访问发现报错403，这个原因是没有读访问资源权限问题 查看nginx.conf配置文件默认没有指定用户 123sudo vim /app/soft/nginx/conf/nginx.conf# 文件第一行内容如下#user nobody; 将该行内容取消注释，并指定用户后保存退出 12# nsn是我的用户user nsn sudo pkill -9 nginx 杀掉nginx进程后 sudo nginx 重启即可]]></content>
      <tags>
        <tag>瞎折腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Volatile、Synchronized、ReentrantLock浅析]]></title>
    <url>%2F2018%2F01%2F09%2FVolatile%E3%80%81Synchronized%E3%80%81ReentrantLock%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Volatile浅析 可以保证内存可见性 不能保证原子性 可以阻止指令重排序 内存可见性 对于volatile变量的读写操作，会添加读写内存屏障，即每次写后刷出到主存，每次读前重新从主存读取，如此保证内存可见性 内存可见性测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com.nsn.concurrent;import com.nsn.jvm.annotation.Runner;import com.nsn.jvm.annotation.VMOption;import com.nsn.jvm.kit.JvmKit;/** * volatile内存可见性测试 */public class VolatileDemo &#123; private static volatile int v_count; private static int count; public static synchronized void syn()&#123; &#125; public static void test_V()&#123; while(v_count == 0)&#123; // &#125; System.out.println("v_count执行结束"); &#125; public static void test()&#123; while(count == 0)&#123; //syn(); //System.out.println(); &#125; System.out.println("count执行结束"); &#125; public static void setCount()&#123; count = 1; v_count = 1; &#125; public static void run()&#123; new Thread(new Runnable() &#123; public void run() &#123; test(); &#125; &#125;,"t_count").start(); new Thread(new Runnable() &#123; public void run() &#123; test_V(); &#125; &#125;,"t_v_count").start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //修改count setCount(); &#125; public static void main(String[] args) &#123; run(); &#125;&#125; 该方法运行后，1s后打印v_count执行结束，程序并未执行结束，t_count线程还在无限循环中，验证了volatile变量的内存可见性 若26行取消注释，则两个线程均执行结束，该处原因则是Synchronized的作用 不能保证原子性操作 单纯的给变量赋值/设置值(获取引用/设置引用)是单原子操作 类似i++操作为复合操作，尽管操作的主体对象为volatile变量，但是并不能使其作为单原子操作来看待，因为其包含取值，加1，再存值三步操作，可使用同步代码块互斥保证源自操作 可以配合CAS操作来保证多线程下只有一个线程更新成功，其他线程失败重试机制，来实现原子性操作 JDK下java.util.concurrent.atomic包下的原子类基于volatile和unsafe类原子操作实现 阻止指令重排序 JMM(Java内存模型)允许在不影响程序功能（满足happen-before原则）的情况下，可对指令进行重排序，单线程下指令重排序并不会产生问题，但是多线程下指令重排序就可能导致异常 指令重排序异常实例1234567891011121314151617181920package com.nsn.concurrent;/** * 双重锁定并发下问题 */public class Singleton &#123; private static Singleton instance; public static Singleton getInstance()&#123; if(instance == null)&#123; synchronized (Singleton.class)&#123; if(instance == null)&#123; //指令重排序可能发生异常 instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 实际上，Java实例化一个对象分为三个操作，正常顺序下 分配内存空间 初始化实例数据 将引用指向内存空间 但是指令重排序后就可能出现如下顺序 分配内存空间 将引用指向内存空间 初始化实例数据 也就是说如果出现此种情况，当前线程将要初始化实例数据时，另一线程获取了该实例并调用了方法，此时就会出现异常此时可以使用volatile来修饰该实例，禁止指令重排序，保证程序正常运行happen-before原则参考博客： http://blog.csdn.net/ns_code/article/details/17348313 Synchronized浅析 类方法锁：锁为该类的Class对象 对象方法锁：锁为当前对象 锁代码块：锁可指定对象 使用synchronized关键字后和普通方法或普通代码块有何异同？ 具有原子性：通过互斥实现，CAS通过失败重试机制实现原子性 具有内存可见性：进入锁方法（代码块）时，先清空工作内存，从主内存重新拷贝变量到当前线程副本，执行完毕后，将更新的变量值刷新到主内存中 JVM层面synchronized的表示 123456789101112131415161718package com.nsn.concurrent;/** * Synchronized关键字测试 */public class SynchronizedDemo &#123; //自定义锁对象 private Object lock = new Object(); //类方法锁 public synchronized static void classSyn()&#123;&#125; //对象方法锁 public synchronized void objectSyn()&#123;&#125; //同步代码块锁 public void codeSyn()&#123; synchronized (lock)&#123;&#125; &#125;&#125; 使用javap命令进行反汇编：javap -c -v SynchronizedDemo12345678910111213141516171819202122232425262728293031323334353637public static synchronized void classSyn(); flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED Code: stack=0, locals=0, args_size=0 0: return LineNumberTable: line 11: 0public synchronized void objectSyn();flags: ACC_PUBLIC, ACC_SYNCHRONIZEDCode: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 13: 0 LocalVariableTable: Start Length Slot Name Signature 0 1 0 this Lcom/nsn/concurrent/SynchronizedDemo;public void codeSyn();flags: ACC_PUBLICCode: stack=2, locals=3, args_size=1 0: aload_0 1: getfield #3 // Field lock:Ljava/lang/Object; 4: dup 5: astore_1 6: monitorenter 7: aload_1 8: monitorexit 9: goto 17 12: astore_2 13: aload_1 14: monitorexit 15: aload_2 16: athrow 17: return 可以看到 对于锁方法，包括类锁方法、对象锁方法，JVM通过ACC_SYNCHRONIZED标志来标识 对于同步代码块，通过monitorenter和monitorexit来操作锁对象的加锁与解锁 关于对象监视器 每个对象都有一个对象监视器与之关联，对象监视器上存在等待关联对象的等待队列 Synchronized锁细分类 相对于volatile被描述为轻量级锁，Synchronized常常被形容成重量级锁，JDK1.6之后，对其进行优化，有如下状态 无锁：没有线程去获取占用锁对象 偏向锁：偏向即意味着偏向已获取锁的线程，发生锁竞争时，升级为轻量级锁 轻量级锁：轻量级体现在发生锁竞争时，不是立刻阻塞失败获取锁的线程，而是尝试自旋一段时间，自旋结束后可能锁对象已经被释放，此时再去获取锁，适用于加锁代码执行快的场景（使用cpu空转时间资源去替换阻塞的消耗） 重量级锁：如果轻量级锁自旋后仍然获取锁失败，就会膨胀成重量级锁，阻塞线程 关于锁状态的标识 在hotspot实现下，每个对象在堆中分配的空间包括三部分 对象头：大小为2/3个字宽，字宽大小根据JVM位数决定，32/64位对应4/8字节,包括MarkWord、指向所属类Class对象的指针、(数组的长度：数组类型才有) 对象实际数据：该部分才是类内部实际定义的对象数据 对齐填充（8字节倍数）：hotspot的自动内存管理系统要求对象起始地址必须是8字节的整数倍 其中MarkWord就用来标识锁的状态（此处说明32位虚拟机下） ReentrantLock浅析]]></content>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jps、Jstack相关使用]]></title>
    <url>%2F2018%2F01%2F03%2FJps%E3%80%81Jstack%E7%9B%B8%E5%85%B3%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[死锁案例分析123456789101112131415161718192021222324252627282930313233343536373839package com.nsn.concurrent;/** * 死锁案例 */public class DeadLockDemo &#123; private static String A = "A"; private static String B = "B"; public static void main(String[] args) &#123; new DeadLockDemo().deadLock(); &#125; private void deadLock()&#123; Thread t1 = new Thread(new Runnable() &#123; public void run() &#123; synchronized (A)&#123; try &#123; Thread.currentThread().sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (B)&#123; System.out.println("t1结束"); &#125; &#125; &#125; &#125;,"thread-A"); Thread t2 = new Thread(new Runnable() &#123; public void run() &#123; synchronized (B)&#123; synchronized (A)&#123; System.out.println("t2结束"); &#125; &#125; &#125; &#125;,"thread-B"); t1.start(); t2.start(); &#125;&#125; jps查看进程id : 1111612345678D:\soft\dev\Java\jdk1.8.0_121\bin&gt;jps6720 Launcher1190822916 Jps22712 Launcher24728 Launcher6152 RemoteMavenServer11116 DeadLockDemo jstack查看死锁信息123456789101112131415D:\soft\dev\Java\jdk1.8.0_121\bin&gt;jstack 11116Java stack information for the threads listed above:===================================================&quot;thread-B&quot;: at com.nsn.concurrent.DeadLockDemo$2.run(DeadLockDemo.java:31) - waiting to lock &lt;0x00000000d608f520&gt; (a java.lang.String) - locked &lt;0x00000000d608f550&gt; (a java.lang.String) at java.lang.Thread.run(Thread.java:745)&quot;thread-A&quot;: at com.nsn.concurrent.DeadLockDemo$1.run(DeadLockDemo.java:22) - waiting to lock &lt;0x00000000d608f550&gt; (a java.lang.String) - locked &lt;0x00000000d608f520&gt; (a java.lang.String) at java.lang.Thread.run(Thread.java:745)Found 1 deadlock. 从堆栈信息中可看出在22行和31行分别需要获取锁B和锁A,二者相互等待，均不释放资源导致死锁预防死锁 避免在加锁方法中获取多个锁若在多个加锁方法中获取多个锁，需保证获取锁的顺序一致 死循环案例分析12345678910package com.nsn.concurrent;public class WhileLockDemo &#123; public static void main(String[] args) &#123; while(true)&#123; &#125; &#125;&#125; jps查看进程id : 2077612345678D:\data\coding\concurrent\demo&gt;jps183369504 Launcher10984 Launcher20776 WhileLockDemo24136 RemoteMavenServer22908 Jps8748 Launcher jstack堆栈信息转储文件1D:\data\coding\concurrent\demo&gt;jstack 20776 &gt; whileLockDemo.dump 复制文件到linux，使用vim查看 明确可能存在死循环的类限定名使用vim进行搜索123&quot;main&quot; #1 prio=5 os_prio=0 tid=0x00000000029de000 nid=0x41c0 runnable [0x000000000298f000] java.lang.Thread.State: RUNNABLE at com.nsn.concurrent.WhileLockDemo.main(WhileLockDemo.java:6) 查看是否是RUNNABLE状态，若是则下一行则可定位到死循环具体行号 Jps配合Jstack使用分析tomcat线程堆栈情况Jps命令 jps：查看java进程id、进程名 jps -l:查看java进程id、进程主类或者jar的完全路径名 jps -v:查看java进程id、进程名、虚拟机参数 jps -q:查看java进程id Jps查看tomcat的java进程id：1381123nsn@ubuntu:/app/data/test$ jps -l1381 org.apache.catalina.startup.Bootstrap19483 sun.tools.jps.Jps Jstack导出dump文件1nsn@ubuntu:/app/data/test$ jstack 1381 &gt; tomcat.dump Jstack分析dump查看线程状态 grep str file : 在文件中过滤出包含该字符串str的行 awk ‘{print $1}’ : 取每行空格分隔的第一列内容 sort : 排序 uniq -c : 分组统计汇总1234567nsn@ubuntu:/app/data/test$ grep java.lang.Thread.State tomcat.dump | awk &apos;&#123;print $2$3$4$5&#125;&apos; | sort | uniq -c 12 RUNNABLE 1 TIMED_WAITING(onobjectmonitor) 1 TIMED_WAITING(parking) 3 TIMED_WAITING(sleeping) 2 WAITING(onobjectmonitor) 20 WAITING(parking)]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发之join方法浅析]]></title>
    <url>%2F2018%2F01%2F03%2FJava%E5%B9%B6%E5%8F%91%E4%B9%8Bjoin%E6%96%B9%E6%B3%95%E6%B5%85%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Thread对象方法join该方法定义在Thread类中，为其对象方法1234567891011121314151617181920212223242526272829public final void join() throws InterruptedException &#123; join(0);&#125;public final synchronized void join(long millis) throws InterruptedException &#123; long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (millis == 0) &#123; while (isAlive()) &#123; wait(0); &#125; &#125; else &#123; while (isAlive()) &#123; long delay = millis - now; if (delay &lt;= 0) &#123; break; &#125; wait(delay); now = System.currentTimeMillis() - base; &#125; &#125;&#125;public final native boolean isAlive(); 此处提供了join有参方法和无参重载（参数值0），此处分析join(0) final修饰，不可被子类修改 synchronized修饰，该方法为加锁方法，锁对象为线程对象本身 内部实际调用Object的wait方法，因为wait需释放锁，前提是获得锁，所以该方法使用synchronized修饰 在调用wait的之前，会通过isAlive()方法判断当前线程对象（作为锁的线程对象）是否存活，非存活状态不做等待操作 对于wait方法的唤醒，我们从方法说明上能够很明显的看到 The thread releases ownership of this monitor and waits until another threadnotifies threads waiting on this object’s monitor to wake upeither through a call to the {@code notify} method or the{@code notifyAll} method. 该方法指明调用wait方法的线程释放其持有的锁，直到其他线程（持有锁）通过调用notify/notifyAll方法去唤醒等待在锁（对象监视器）上的线程然而我们在编码的层面并没有显式的去调用notify/notifyAll方法去唤醒之前等待的线程实际上该操作是由线程执行子系统在线程执行完毕后，去调用notify/notifyAll方法来实现等待的线程唤醒此处可以猜想为什么join是Thread的方法，而不和wait一样定义成Object的方法的原因？ 首先若要通过join方法来控制线程的执行顺序，实际上是将线程对象作为锁对象，让后执行的线程加入到锁对象（先执行的线程）的等待队列上，如此说明，只有线程对象才能满足作为锁的条件，因此该方法只定义在Thread类中。]]></content>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Idea快捷键小计]]></title>
    <url>%2F2017%2F12%2F28%2FIdea%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%B0%8F%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[idea常用快捷键 double Shift 在任意处搜索文件 Ctrl + Shift + F 全局搜索文本内容 Ctrl + Shift + R 全局替换文本内容 Ctrl + H 查看当前类继承树 Ctrl + F12 查看当前类的成员（等价eclipse Ctrl + O） Alt + Shift + F10 快速运行已配置运行入口 Alt + F12 打开控制台 Alt + &lt; 返回上一光标（自定义 Back） Alt + &gt; 返回下一光标（自定义 Forword） Alt + 上 光标移动到当前页面上一个方法 Alt + 下 光标移动到当前页面下一个方法 Alt + F7 查看当前方法的调用关系（被谁调用）]]></content>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis学习（一）]]></title>
    <url>%2F2017%2F12%2F27%2FMybatis%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[mybatis配置文件解析 对于配置文件，最直观的入口就是其DTD（Document Type Define） mybatis配置约束文档&nbsp;&nbsp;http://mybatis.org/dtd/mybatis-3-config.dtd mybatis映射约束文档&nbsp;&nbsp;http://mybatis.org/dtd/mybatis-3-mapper.dtd DTD语法介绍&nbsp;&nbsp;http://www.w3school.com.cn/dtd/index.asp mybatis用法文档&nbsp;&nbsp;http://www.mybatis.org/mybatis-3/zh/index.html mybatis配置-DTD解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;?xml version="1.0" encoding="UTF-8" ?&gt;#定义configuration元素，后序括号中为其包含的子元素，其中每个子元素至多1个，且先后顺序需严格按照括号中的顺序进行定义&lt;!ELEMENT configuration (properties?, settings?, typeAliases?, typeHandlers?, objectFactory?, objectWrapperFactory?, plugins?, environments?, databaseIdProvider?, mappers?)&gt;#定义元素databaseIdProvider拥有n(n&gt;=0)个property元素&lt;!ELEMENT databaseIdProvider (property*)&gt;#为元素databaseIdProvider定义字符数据类型（CDATA）的属性，属性名为type，其值为必填项（#REQUIRED）&lt;!ATTLIST databaseIdProvidertype CDATA #REQUIRED&gt;&lt;!ELEMENT properties (property*)&gt;#为元素properties定义字符数据类型（CDATA）的属性，属性名为resource，其值为非必填项（#IMPLIED）#为元素properties定义字符数据类型（CDATA）的属性，属性名为url，其值为非必填项（#IMPLIED）&lt;!ATTLIST propertiesresource CDATA #IMPLIEDurl CDATA #IMPLIED&gt;#定义元素property，该元素声明为空元素，即单闭合标签（&lt;property /&gt;），不包含内容，通过属性的key:value体现其内容&lt;!ELEMENT property EMPTY&gt;#为元素property定义字符数据类型（CDATA）的属性，属性名为name，其值为必填项（#REQUIRED）#为元素property定义字符数据类型（CDATA）的属性，属性名为value，其值为必填项（#REQUIRED）#property元素一般用于配置JavaBean的属性映射，name映射字段名，value映射字段值&lt;!ATTLIST propertyname CDATA #REQUIREDvalue CDATA #REQUIRED&gt;&lt;!ELEMENT settings (setting+)&gt;&lt;!ELEMENT setting EMPTY&gt;&lt;!ATTLIST settingname CDATA #REQUIREDvalue CDATA #REQUIRED&gt;&lt;!ELEMENT typeAliases (typeAlias*,package*)&gt;&lt;!ELEMENT typeAlias EMPTY&gt;&lt;!ATTLIST typeAliastype CDATA #REQUIREDalias CDATA #IMPLIED&gt;&lt;!ELEMENT typeHandlers (typeHandler*,package*)&gt;&lt;!ELEMENT typeHandler EMPTY&gt;&lt;!ATTLIST typeHandlerjavaType CDATA #IMPLIEDjdbcType CDATA #IMPLIEDhandler CDATA #REQUIRED&gt;&lt;!ELEMENT objectFactory (property*)&gt;&lt;!ATTLIST objectFactorytype CDATA #REQUIRED&gt;&lt;!ELEMENT objectWrapperFactory (property*)&gt;&lt;!ATTLIST objectWrapperFactorytype CDATA #REQUIRED&gt;&lt;!ELEMENT plugins (plugin+)&gt;&lt;!ELEMENT plugin (property*)&gt;&lt;!ATTLIST plugininterceptor CDATA #REQUIRED&gt;&lt;!ELEMENT environments (environment+)&gt;&lt;!ATTLIST environmentsdefault CDATA #REQUIRED&gt;&lt;!ELEMENT environment (transactionManager,dataSource)&gt;&lt;!ATTLIST environmentid CDATA #REQUIRED&gt;&lt;!ELEMENT transactionManager (property*)&gt;&lt;!ATTLIST transactionManagertype CDATA #REQUIRED&gt;&lt;!ELEMENT dataSource (property*)&gt;&lt;!ATTLIST dataSourcetype CDATA #REQUIRED&gt;&lt;!ELEMENT mappers (mapper*,package*)&gt;&lt;!ELEMENT mapper EMPTY&gt;&lt;!ATTLIST mapperresource CDATA #IMPLIEDurl CDATA #IMPLIEDclass CDATA #IMPLIED&gt;&lt;!ELEMENT package EMPTY&gt;&lt;!ATTLIST packagename CDATA #REQUIRED&gt; 通过DTD文档，不仅能看出配置文件能够定义的类型以及规则，同时能看出mybatis对外暴露的扩展机制 environments元素体现了多环境的配置 transactionManager元素可引入三方事务管理器，如spring的事务管理 dataSource元素同样可引入三方数据库连接池 plugins元素采用插件机制，mybatis提供相关插件拓展的接口，使用户可自定义插件（对返回结果进行自定义处理）集成至mybatis typeHandlers元素用于 mybatis映射-DTD解析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;#定义根元素mapper，内部可包含以下元素任意顺序数量组合&lt;!ELEMENT mapper (cache-ref | cache | resultMap* | parameterMap* | sql* | insert* | update* | delete* | select* )+&gt;#定义元素mapper的命名空间&lt;!ATTLIST mappernamespace CDATA #IMPLIED&gt;#定义元素cache-ref引用其他命名空间的缓存&lt;!ELEMENT cache-ref EMPTY&gt;&lt;!ATTLIST cache-refnamespace CDATA #REQUIRED&gt;#定义元素cache，mybatis的缓存配置&lt;!ELEMENT cache (property*)&gt;&lt;!ATTLIST cachetype CDATA #IMPLIEDeviction CDATA #IMPLIEDflushInterval CDATA #IMPLIEDsize CDATA #IMPLIEDreadOnly CDATA #IMPLIEDblocking CDATA #IMPLIED&gt;#定义元素parameterMap，用于映射实体字段和数据库列名&lt;!ELEMENT parameterMap (parameter+)?&gt;#为parameterMap定义属性，用于指定该parameterMap的id（同一命名空间内唯一），以及指定映射的实体类类型（类的限定名）&lt;!ATTLIST parameterMapid CDATA #REQUIREDtype CDATA #REQUIRED&gt;#单闭合标签，用于映射实体类字段和数据库列名&lt;!ELEMENT parameter EMPTY&gt;#property指定实体类字段名（必须）#javaType指定该字段的Java类型#jdbcType指定映射数据库列的类型#typeHandler指定数据类型转换（Java-&gt;数据库）&lt;!ATTLIST parameterproperty CDATA #REQUIREDjavaType CDATA #IMPLIEDjdbcType CDATA #IMPLIEDmode (IN | OUT | INOUT) #IMPLIEDresultMap CDATA #IMPLIEDscale CDATA #IMPLIEDtypeHandler CDATA #IMPLIED&gt;#定义resultMap元素，用于指定对数据库执行结果的处理类型&lt;!ELEMENT resultMap (constructor?,id*,result*,association*,collection*, discriminator?)&gt;#id用于指定该resultMap的id（同一命名空间唯一）#type用于指定resultMap的实际处理类型（某个实体类类型）&lt;!ATTLIST resultMapid CDATA #REQUIREDtype CDATA #REQUIREDextends CDATA #IMPLIEDautoMapping (true|false) #IMPLIED&gt;&lt;!ELEMENT constructor (idArg*,arg*)&gt;#id用于指定主键列&lt;!ELEMENT id EMPTY&gt;&lt;!ATTLIST idproperty CDATA #IMPLIEDjavaType CDATA #IMPLIEDcolumn CDATA #IMPLIEDjdbcType CDATA #IMPLIEDtypeHandler CDATA #IMPLIED&gt;#result用于指定非主键列&lt;!ELEMENT result EMPTY&gt;&lt;!ATTLIST resultproperty CDATA #IMPLIEDjavaType CDATA #IMPLIEDcolumn CDATA #IMPLIEDjdbcType CDATA #IMPLIEDtypeHandler CDATA #IMPLIED&gt;&lt;!ELEMENT idArg EMPTY&gt;&lt;!ATTLIST idArgjavaType CDATA #IMPLIEDcolumn CDATA #IMPLIEDjdbcType CDATA #IMPLIEDtypeHandler CDATA #IMPLIEDselect CDATA #IMPLIEDresultMap CDATA #IMPLIEDname CDATA #IMPLIED&gt;&lt;!ELEMENT arg EMPTY&gt;&lt;!ATTLIST argjavaType CDATA #IMPLIEDcolumn CDATA #IMPLIEDjdbcType CDATA #IMPLIEDtypeHandler CDATA #IMPLIEDselect CDATA #IMPLIEDresultMap CDATA #IMPLIEDname CDATA #IMPLIED&gt;&lt;!ELEMENT collection (constructor?,id*,result*,association*,collection*, discriminator?)&gt;&lt;!ATTLIST collectionproperty CDATA #REQUIREDcolumn CDATA #IMPLIEDjavaType CDATA #IMPLIEDofType CDATA #IMPLIEDjdbcType CDATA #IMPLIEDselect CDATA #IMPLIEDresultMap CDATA #IMPLIEDtypeHandler CDATA #IMPLIEDnotNullColumn CDATA #IMPLIEDcolumnPrefix CDATA #IMPLIEDresultSet CDATA #IMPLIEDforeignColumn CDATA #IMPLIEDautoMapping (true|false) #IMPLIEDfetchType (lazy|eager) #IMPLIED&gt;#指定关联查询&lt;!ELEMENT association (constructor?,id*,result*,association*,collection*, discriminator?)&gt;&lt;!ATTLIST associationproperty CDATA #REQUIREDcolumn CDATA #IMPLIEDjavaType CDATA #IMPLIEDjdbcType CDATA #IMPLIEDselect CDATA #IMPLIEDresultMap CDATA #IMPLIEDtypeHandler CDATA #IMPLIEDnotNullColumn CDATA #IMPLIEDcolumnPrefix CDATA #IMPLIEDresultSet CDATA #IMPLIEDforeignColumn CDATA #IMPLIEDautoMapping (true|false) #IMPLIEDfetchType (lazy|eager) #IMPLIED&gt;&lt;!ELEMENT discriminator (case+)&gt;&lt;!ATTLIST discriminatorcolumn CDATA #IMPLIEDjavaType CDATA #REQUIREDjdbcType CDATA #IMPLIEDtypeHandler CDATA #IMPLIED&gt;&lt;!ELEMENT case (constructor?,id*,result*,association*,collection*, discriminator?)&gt;&lt;!ATTLIST casevalue CDATA #REQUIREDresultMap CDATA #IMPLIEDresultType CDATA #IMPLIED&gt;&lt;!ELEMENT property EMPTY&gt;&lt;!ATTLIST propertyname CDATA #REQUIREDvalue CDATA #REQUIRED&gt;#用于定义别名&lt;!ELEMENT typeAlias EMPTY&gt;&lt;!ATTLIST typeAliasalias CDATA #REQUIREDtype CDATA #REQUIRED&gt;#定义select语句&lt;!ELEMENT select (#PCDATA | include | trim | where | set | foreach | choose | if | bind)*&gt;#id select语句的id#parameterMap 参数map（需定义）#parameterType 参数type（实体类限定名）#resultMap CDATA 结果map（需定义）#resultType CDATA 结果type（实体类限定名）&lt;!ATTLIST selectid CDATA #REQUIREDparameterMap CDATA #IMPLIEDparameterType CDATA #IMPLIEDresultMap CDATA #IMPLIEDresultType CDATA #IMPLIEDresultSetType (FORWARD_ONLY | SCROLL_INSENSITIVE | SCROLL_SENSITIVE) #IMPLIEDstatementType (STATEMENT|PREPARED|CALLABLE) #IMPLIEDfetchSize CDATA #IMPLIEDtimeout CDATA #IMPLIEDflushCache (true|false) #IMPLIEDuseCache (true|false) #IMPLIEDdatabaseId CDATA #IMPLIEDlang CDATA #IMPLIEDresultOrdered (true|false) #IMPLIEDresultSets CDATA #IMPLIED &gt;&lt;!ELEMENT insert (#PCDATA | selectKey | include | trim | where | set | foreach | choose | if | bind)*&gt;&lt;!ATTLIST insertid CDATA #REQUIREDparameterMap CDATA #IMPLIEDparameterType CDATA #IMPLIEDtimeout CDATA #IMPLIEDflushCache (true|false) #IMPLIEDstatementType (STATEMENT|PREPARED|CALLABLE) #IMPLIEDkeyProperty CDATA #IMPLIEDuseGeneratedKeys (true|false) #IMPLIEDkeyColumn CDATA #IMPLIEDdatabaseId CDATA #IMPLIEDlang CDATA #IMPLIED&gt;&lt;!ELEMENT selectKey (#PCDATA | include | trim | where | set | foreach | choose | if | bind)*&gt;&lt;!ATTLIST selectKeyresultType CDATA #IMPLIEDstatementType (STATEMENT|PREPARED|CALLABLE) #IMPLIEDkeyProperty CDATA #IMPLIEDkeyColumn CDATA #IMPLIEDorder (BEFORE|AFTER) #IMPLIEDdatabaseId CDATA #IMPLIED&gt;&lt;!ELEMENT update (#PCDATA | selectKey | include | trim | where | set | foreach | choose | if | bind)*&gt;&lt;!ATTLIST updateid CDATA #REQUIREDparameterMap CDATA #IMPLIEDparameterType CDATA #IMPLIEDtimeout CDATA #IMPLIEDflushCache (true|false) #IMPLIEDstatementType (STATEMENT|PREPARED|CALLABLE) #IMPLIEDkeyProperty CDATA #IMPLIEDuseGeneratedKeys (true|false) #IMPLIEDkeyColumn CDATA #IMPLIEDdatabaseId CDATA #IMPLIEDlang CDATA #IMPLIED&gt;&lt;!ELEMENT delete (#PCDATA | include | trim | where | set | foreach | choose | if | bind)*&gt;&lt;!ATTLIST deleteid CDATA #REQUIREDparameterMap CDATA #IMPLIEDparameterType CDATA #IMPLIEDtimeout CDATA #IMPLIEDflushCache (true|false) #IMPLIEDstatementType (STATEMENT|PREPARED|CALLABLE) #IMPLIEDdatabaseId CDATA #IMPLIEDlang CDATA #IMPLIED&gt;&lt;!-- Dynamic --&gt;&lt;!ELEMENT include (property+)?&gt;&lt;!ATTLIST includerefid CDATA #REQUIRED&gt;&lt;!ELEMENT bind EMPTY&gt;&lt;!ATTLIST bind name CDATA #REQUIRED value CDATA #REQUIRED&gt;&lt;!ELEMENT sql (#PCDATA | include | trim | where | set | foreach | choose | if | bind)*&gt;&lt;!ATTLIST sqlid CDATA #REQUIREDlang CDATA #IMPLIEDdatabaseId CDATA #IMPLIED&gt;&lt;!ELEMENT trim (#PCDATA | include | trim | where | set | foreach | choose | if | bind)*&gt;&lt;!ATTLIST trimprefix CDATA #IMPLIEDprefixOverrides CDATA #IMPLIEDsuffix CDATA #IMPLIEDsuffixOverrides CDATA #IMPLIED&gt;&lt;!ELEMENT where (#PCDATA | include | trim | where | set | foreach | choose | if | bind)*&gt;&lt;!ELEMENT set (#PCDATA | include | trim | where | set | foreach | choose | if | bind)*&gt;&lt;!ELEMENT foreach (#PCDATA | include | trim | where | set | foreach | choose | if | bind)*&gt;&lt;!ATTLIST foreachcollection CDATA #REQUIREDitem CDATA #IMPLIEDindex CDATA #IMPLIEDopen CDATA #IMPLIEDclose CDATA #IMPLIEDseparator CDATA #IMPLIED&gt;&lt;!ELEMENT choose (when* , otherwise?)&gt;&lt;!ELEMENT when (#PCDATA | include | trim | where | set | foreach | choose | if | bind)*&gt;&lt;!ATTLIST whentest CDATA #REQUIRED&gt;&lt;!ELEMENT otherwise (#PCDATA | include | trim | where | set | foreach | choose | if | bind)*&gt;&lt;!ELEMENT if (#PCDATA | include | trim | where | set | foreach | choose | if | bind)*&gt;&lt;!ATTLIST iftest CDATA #REQUIRED&gt;]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用软件下载链接]]></title>
    <url>%2F2017%2F12%2F20%2F%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[switchHosts一款便捷的hosts切换工具github下载地址1https://github.com/oldj/SwitchHosts/releases 百度网盘下载地址1https://pan.baidu.com/share/link?shareid=150951&amp;uk=3607385901#list/path=%2F]]></content>
      <tags>
        <tag>软件下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu常用软件下载地址]]></title>
    <url>%2F2017%2F12%2F18%2Fubuntu%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%2F</url>
    <content type="text"><![CDATA[tomcat71http://mirrors.hust.edu.cn/apache/tomcat/tomcat-8/v8.5.24/bin/apache-tomcat-8.5.24.tar.gz 花生壳1https://hsk.oray.com/download/download?id=25]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[花生壳相关操作]]></title>
    <url>%2F2017%2F12%2F18%2F%E8%8A%B1%E7%94%9F%E5%A3%B3%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[花生壳arm-linux安装花生壳下载1wget https://hsk.oray.com/download/download?id=25 -O /app/backup/hsk.deb 花生壳安装1sudo dpkg -i hsk.deb 花生壳启动1phddns start]]></content>
      <tags>
        <tag>花生壳</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu常用操作]]></title>
    <url>%2F2017%2F12%2F18%2Fubuntu%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[ubuntu下初始root用户1sudo passwd ubuntu下用户操作创建用户修改用户密码指定用户目录针对目录对用户赋权删除用户更改文件所属用户、所属组1234# 更改文件file所属用户为usernamesudo chown username file# 更改文件file所属用户组为groupsudo chgrp group file 若要更改文件夹，则添加-R参数（recursive递归） ubuntu下更换阿里软件源备份原有软件源123cd /etc/apt/sudo mv sources.list sources.list.baksudo vim sources.list 添加如下源地址123456789101112131415161718# deb cdrom:[Ubuntu 16.04 LTS _Xenial Xerus_ - Release amd64 (20160420.1)]/ xenial main restricteddeb-src http://archive.ubuntu.com/ubuntu xenial main restricted #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial universedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates universedeb http://mirrors.aliyun.com/ubuntu/ xenial multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse #Added by software-propertiesdeb http://archive.canonical.com/ubuntu xenial partnerdeb-src http://archive.canonical.com/ubuntu xenial partnerdeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricteddeb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted multiverse universe #Added by software-propertiesdeb http://mirrors.aliyun.com/ubuntu/ xenial-security universedeb http://mirrors.aliyun.com/ubuntu/ xenial-security multiverse 更新软件源1sudo apt update 修改时区，输入一下命令后选择ShangHai1dpkg-reconfigure tzdata ubuntu下使用ufw防火墙安装ufw1sudo apt install ufw 开启指定端口注意启动防火墙前先开启22端口1234#开启22端口sudo ufw allow 22#开启3306端口sudo ufw allow 3306 开启ufw1sudo ufw enable 查看ufw开启的端口1sudo ufw status 生效ufw1sudo ufw reload 关闭ufw1sudo ufw disable ubuntu服务开机启动 ubuntu下ssh和scp命令ssh连接1ssh nsn@192.168.1.101 ssh指定端口连接1ssh nsn@192.168.1.101 -p 26 ssh指连接执行命令1ssh nsn@192.168.1.101 &quot;cd /app &amp;&amp; ls&quot; scp传输文件1scp ./demo.tar nsn@192.168.1.101:/home/nsn/demo.tar scp指定端口传输文件1scp -P 26 ./demo.tar nsn@192.168.1.101:~ scp传输目录1scp ./demo/* nsn@192.168.1.101:/home/nsn/demo ubuntu下tar命令解压缩1tar xzvf xxx.tar.gz 压缩1tar czvf xxx.tar.gz dir ubuntu下ssh授信生成ssh公钥1ssh-keygen 复制公钥到目标主机12cd ~/.sshscp ./id_rsa.pub nsn@192.168.1.101:~/rsa.pub 目标主机操作进入用户目录1cd ~ 创建.ssh目录（存在忽略）1mkdir .ssh 创建authorized_keys文件（存在忽略）1touch ./.ssh/authorized_keys 复制公钥内容至authorized_keys文件12cat ./rsa.pub &gt;&gt; .ssh/authorized_keysrm -rf ./rsa.pub 注意cat可以合并多个文件cat file1 file2，即合并file1和file2的输出，同时&gt;为覆盖，&gt;&gt;为追加 linuxdeploy下安装ubuntu安装源1http://mirror.tuna.tsinghua.edu.cn/ubuntu-ports/]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql的使用学习（一）]]></title>
    <url>%2F2017%2F12%2F18%2Fmysql%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ubuntu下mysql的安装安装mysql-server1sudo apt install mysql-server 安装mysql-client1sudo apt install mysql-client 配置mysql可被外界访问关闭地址绑定1234#可能存在于my.cnf引入的文件中sudo vim my.cnf#注释bind-address = 127.0.0.1#bind-address = 127.0.0.1 开启root用户可远程连接1234567#登录mysqlmysql -uroot -p#更新用户可被远程任意ip访问update mysql.user set host=&apos;%&apos; where user = &apos;root&apos;;#刷新权限flush privileges;quit 启动mysql服务12Usage: /etc/init.d/mysql start|stop|restart|reload|force-reload|statussudo service mysql start 配置开放端口 该问题遇见在arm-ubuntu-16.04针对启动mysql服务时开启Socket失败问题，需配置将mysql用户加入到inet用户组12345sudo vim /etc/group#vim搜索inet/inet#添加mysqlaid_inet:x:3003:nsn,root,mysql 配置远程连接 使用ufw开启3306端口：ubuntu防火墙的使用 mysql相关操作mysql登陆1mysql -uroot -p mysql创建用户123#host为%号，则任意ip可连接#host也可指定单独ip，如192.168.1.101create user &apos;username&apos;@&apos;host&apos; identified by &apos;password&apos;; mysql修改密码使用命令修改（修改当前用户）1set password = password(&apos;new password&apos;); 使用命令修改（修改其他用户）1set password for &apos;username&apos;@&apos;host&apos; = password(&apos;new password&apos;); 使用update语句修改1234#mysql 5.7 之前密码字段为passwordupdate mysql.user set authentication_string = password(&apos;password&apos;) where user = &apos;username&apos;;#使用语句修改需要刷新flush privileges; mysql分配权限分配用户操作权限12345#databasename.tablename可使用通配符*.*#不带分配权限grant privileges on databasename.tablename to &apos;username&apos;@&apos;host&apos;;#带分配权限grant privileges on databasename.tablename to &apos;username&apos;@&apos;host&apos; with grant option; 分配权限实例1234#分配所有权限grant all on databasename.tablename to &apos;username&apos;@&apos;host&apos;;#分配查询和插入权限grant select,insert on databasename.tablename to &apos;username&apos;@&apos;host&apos;; mysql查看用户权限1show grants for &apos;username&apos;@&apos;host&apos;; mysql撤销权限撤销权限的privilege、databasename、tablename必须和授权的内容完全一致才可撤销1revoke privilege on databasename.tablename from &apos;username&apos;@&apos;host&apos;; mysql删除用户使用命令删除1drop user &apos;username&apos;@&apos;host&apos;; 使用delete语句修改123delete from mysql.user where user = &apos;username&apos;;#使用语句修改需要刷新flush privileges; mysql权限列表 权限 权限说明 ALTER Allows use of ALTER TABLE. ALTER ROUTINE Alters or drops stored routines. CREATE Allows use of CREATE TABLE. CREATE ROUTINE Creates stored routines. CREATE TEMPORARY TABLE Allows use of CREATE TEMPORARY TABLE. CREATE USER Allows use of CREATE USER, DROP USER, RENAME USER, and REVOKE ALL PRIVILEGES. CREATE VIEW Allows use of CREATE VIEW. DELETE Allows use of DELETE. DROP Allows use of DROP TABLE. EXECUTE Allows the user to run stored routines. FILE Allows use of SELECT… INTO OUTFILE and LOAD DATA INFILE. INDEX Allows use of CREATE INDEX and DROP INDEX. INSERT Allows use of INSERT. LOCK TABLES Allows use of LOCK TABLES on tables for which the user also has SELECT privileges. PROCESS Allows use of SHOW FULL PROCESSLIST. RELOAD Allows use of FLUSH. REPLICATION Allows the user to ask where slave or master CLIENT servers are. REPLICATION SLAVE Needed for replication slaves. SELECT Allows use of SELECT. SHOW DATABASES Allows use of SHOW DATABASES. SHOW VIEW Allows use of SHOW CREATE VIEW. SHUTDOWN Allows use of mysqladmin shutdown. SUPER Allows use of CHANGE MASTER, KILL, PURGE MASTER LOGS, and SET GLOBAL SQL statements. Allows mysqladmin debug command. Allows one extra connection to be made if maximum connections are reached. UPDATE Allows use of UPDATE. USAGE Allows connection without any specific privileges.]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
